{"meta":{"title":"Emilyty","subtitle":"software","description":"software","author":"Emilyty","url":"https://emilyty.github.io","root":"/"},"pages":[{"title":"","date":"2020-11-13T15:25:20.927Z","updated":"2020-11-13T15:25:20.927Z","comments":false,"path":"categories/index.html","permalink":"https://emilyty.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-13T15:23:17.877Z","updated":"2020-11-13T15:23:17.877Z","comments":false,"path":"tags/index.html","permalink":"https://emilyty.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"遇到的软件需求评审到发布的流程","slug":"遇到的软件需求评审到发布的流程","date":"2020-11-14T06:50:34.000Z","updated":"2020-11-14T07:33:16.373Z","comments":true,"path":"2020/11/14/遇到的软件需求评审到发布的流程/","link":"","permalink":"https://emilyty.github.io/2020/11/14/%E9%81%87%E5%88%B0%E7%9A%84%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%AF%84%E5%AE%A1%E5%88%B0%E5%8F%91%E5%B8%83%E7%9A%84%E6%B5%81%E7%A8%8B/","excerpt":"","text":"分享一下目前正在执行中的需求评审到发布的测试流程，主要是针对产品开发，项目开发的流程跟这个稍有区别。 需求评审 组织者：产品经理 参与人员：开发、测试、产品经理、相关领导 目的：确认需求是否完整、业务逻辑是否合理 通过标准：需求不存在逻辑漏洞，文档相对完善 作为测试人员可以做的事情：①提前阅读需求文档；②评审前或者评审中积极参与讨论，提出建议；③需求明显不合理的情况下有勇气拒绝； 任务拆分和评估 组织者：测试负责人（master） 参与人员：开发、测试、产品经理 任务拆分原则：可独立测试；必现实现和可选择实现的任务分开；可以发布和暂时不能发布的任务拆开；拆分后的任务可评估，不能太大； 测试方案和用例设计 公司内部统一测试用例编写方式，便于后期管理和维护； 尽量指定同一个人来编写，可以保持用例设计方法一致，后期维护快捷； 统一测试用例编写工具。 测试方案模板统一。 测试方案和用例评审 组织者：方案和用例设计者 参与人员：测试领导、测试人员、开发、产品经理 目的：用例和方案设计是否合理，逻辑是否清晰；覆盖率是否达标，有无遗漏点；对需求文档理解是否一致； 冒烟测试 - 执行者：开发或者测试人员 目的：冒烟通过是测试准入的标准，如果冒烟都不通过，那么就没有必要浪费时间了。 通常公司都要求开发自测，如果开发一直说已自测过，但是经常冒烟都不通过的情况下，测试可以提供一些冒烟用例给开发进行自测。 系统测试 - 执行测试：测试人员 测试方式：手动或者自动 注意试项：用例需要标注通过或失败；有问题必须建issue，不能口头通知后直接进行修改； 测试报告 编写人员：测试人员 注意试项：测试报告格式统一；包含发布风险和测试结果；包含依赖服务编排和测试通过编排；还可以增加更多的质量统计数据； 预发布环境验证 执行者：测试人员 目的：防止升级失败；一定程度上可以发现程序里写死某些环境变量的问题；验证开发提供的升级流程和运维编写的发布脚本是否正确； 最后附上流程图一张","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://emilyty.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://emilyty.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"软件测试流程","slug":"软件测试流程","permalink":"https://emilyty.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"}]},{"title":"jmeter如何连接mysql数据库","slug":"jmeter如何连接mysql数据库","date":"2018-02-23T07:24:57.000Z","updated":"2020-11-14T08:38:21.193Z","comments":true,"path":"2018/02/23/jmeter如何连接mysql数据库/","link":"","permalink":"https://emilyty.github.io/2018/02/23/jmeter%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"首先下载mysql驱动包（下载地址：http://download.csdn.net/download/emilyty/9586858）。然后把mysql的驱动包放在jmeter的lib目录下。 jmeter如何连接mysql数据库 1、在测试计划里引入mysql驱动包 点击【浏览】按钮，在jmeter/lib目录下选择mysql驱动包。如图所示： 2.添加线程组 选中测试计划-&gt;右键-&gt;添加-&gt;Threads(Users)-&gt;线程组 2 3.添加配置元件JDBC Connection Configuration 在线程组下添加JDBC Connection Configuration，添加方式如图所示： 3 4.配置JDBC Connection Configuration Variable Name： 变量名称，需要变量名绑定到池。需要唯一标识。与JDBC取样器中的相对应，决定JDBC取样的配置。简单理解就是在JDBC request的时候确定去哪个绑定的配置。 MaxNumber of Connection： 数据库最大链接数 PoolTimeout： 数据库链接超时，单位ms Idle Cleanup Interval （ms）： 数据库空闲清理的间隔时间，单位ms Auto Commit：自动提交。有三个选项，true、false、编辑（自己通过jmeter提供的函数设置） Transaction Isolation：事务间隔级别设置，主要有如下几个选项：（对JMX加解密） TRANSACTION_REPEATABLE_READ事务重复读、TRANSACTION_READ_COMMITTED事务已提交读 TRANSACTION_SERIALIZABLE事务序列TRANSACTION_READ_UNCOMMITTED事务未提交读、TRANSACTION_NODE事务节点、DEFAULT默认、编辑 Keep-Alive： 是否保持连接 Max Connection age （ms）：最大连接时长，超过时长的会被拒绝 Validation Query：验证查询，检验连接是否有效（数据库重启后之前的连接都失效，需要验证查询） Database URL：如jdbc:mysql://localhost:3306/test，表示本地数据库，3306端口，请求访问的数据库名称为test，如果是远程数据库，例如数据库所在服务器IP为：192.168.11.120，请求的数据库名称为UserInfo，URL为dbc:mysql://192.168.11.120:3306/UserInfo JDBCDriver Class： JDBC的类，如com.mysql.jdbc.Driver 5.添加jdbc request 在线程组下添加sampler-&gt;jdbc request 5 jdbc request中填写sql语句。 注意：variable name必须跟JDBC Connection Configuration里设置的variable name一致。 6.查看结果 添加查看结果树，聚合报告。 点击运行，运行结束后，查看结果。","categories":[{"name":"测试工具","slug":"测试工具","permalink":"https://emilyty.github.io/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://emilyty.github.io/tags/jmeter/"}]},{"title":"Config参数化方法","slug":"Config参数化方法","date":"2016-01-14T05:28:15.000Z","updated":"2020-11-14T07:56:04.353Z","comments":true,"path":"2016/01/14/Config参数化方法/","link":"","permalink":"https://emilyty.github.io/2016/01/14/Config%E5%8F%82%E6%95%B0%E5%8C%96%E6%96%B9%E6%B3%95/","excerpt":"","text":"1.创建csv文件，把需要的参数写在一列中。不需要写变量名称，直接写变量值就可以。 2.线程组中添加CSV Data Set Config 如图所示： ​ 3.设置CSV Data Set Config配置 ​ Filename中填写文件路径和文件名称。如果文件放在jmeter的bin目录下，直接写文件名称就可以。 Variable names中填写自定义变量名称。 Recycle on EOF：到了文件尾处，是否循环读取参数。 Stop thread on EOF:到了文件尾处，是否停止线程。 当Recycle on EOF选择true时，Stop threadon EOF选择true和false无任何意义，通俗的讲，在前面控制了不停的循环读取，后面再来让stop或run没有任何意义 当Recycle on EOF选择false时，Stop threadon EOF选择true，线程4个，参数3个，那么只会请求3次 当Recycle on EOF选择false时，Stop thread on EOF选择false，线程4个，参数3个，那么会请求4次，但第4次没有参数可取，不让循环，所以第4次请求错误 4.参数化固定值 需要使用变量的地方换成自定的变量名称，编写格式：${自定义的变量名称}，如图所示的格式填写： 1-3 5.循环读取参数： 1）通过线程组循环 Recycle on EOF和Stop thread on EOF进行设置，还需要把线程组的循环次数设置为需要的次数。 2）通过循环控制器循环 如果使用循环控制器的话，可以把线程组设置为1，需要循环的次数在循环控制器中设置。配合着Recycle on EOF和Stop thread on EOF的设置使用。 注：如果使用循环控制器，需要把CSV Data Set Config放在循环控制器下面。","categories":[{"name":"测试工具","slug":"测试工具","permalink":"https://emilyty.github.io/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://emilyty.github.io/tags/jmeter/"}]}],"categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://emilyty.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"测试工具","slug":"测试工具","permalink":"https://emilyty.github.io/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://emilyty.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"软件测试流程","slug":"软件测试流程","permalink":"https://emilyty.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"},{"name":"jmeter","slug":"jmeter","permalink":"https://emilyty.github.io/tags/jmeter/"}]}