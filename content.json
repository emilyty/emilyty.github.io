{"meta":{"title":"Emilyty","subtitle":"software testing","description":"software testing","author":"Emilyty","url":"https://emilyty.github.io","root":"/"},"pages":[{"title":"","date":"2020-11-13T15:25:20.927Z","updated":"2020-11-13T15:25:20.927Z","comments":false,"path":"categories/index.html","permalink":"https://emilyty.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-13T15:23:17.877Z","updated":"2020-11-13T15:23:17.877Z","comments":false,"path":"tags/index.html","permalink":"https://emilyty.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"jmeter之time和timeShift函数","slug":"jmeter的time和timeShift函数","date":"2021-02-02T06:09:06.000Z","updated":"2021-02-02T07:58:17.308Z","comments":true,"path":"2021/02/02/jmeter的time和timeShift函数/","link":"","permalink":"https://emilyty.github.io/2021/02/02/jmeter%E7%9A%84time%E5%92%8CtimeShift%E5%87%BD%E6%95%B0/","excerpt":"","text":"time函数 该函数可获取系统当前时间。默认的情况下获取的是当前时间戳。 该函数有两个参数可填。 第一个参数是格式化当前时间，填写后返回对应格式的时间。 第二个函数是设置变量名称的函数，可以通过这个变量调用返回的值。 如图所示： timeShift函数 该函数可以实现时间位移。该函数默认也是获取当前时间戳。 第一个参数是格式化时间。填写后返回对应格式的时间，如果不填写返回时间戳。 我需要常用的格式： 12345$&#123;__timeShift(yyyy&#x2F;MM&#x2F;dd HH:mm:ss:SSS,,,,)&#125;$&#123;__timeShift(yyyy&#x2F;MM&#x2F;dd HH:mm:ss,,,,)&#125;$&#123;__timeShift(yyyy-MM-dd&#39;T&#39;HH:mm:ss:SSS&#39;Z&#39;,,,,)&#125;$&#123;__timeShift(yyyy-MM-dd HH:mm:ss:SSS,,,,)&#125;$&#123;__timeShift(yyyy-MM-dd&#39;T&#39;HH:mm:ss:SSS+08:00,,,,)&#125; 第二个参数，没发现什么用处。 第三个参数是时间位移。“-”表示减时间，“+”或者无符号表示加时间。大写“P”为固定前缀，【D,H,M,S】为时间单位。”D”为天，“H”为小时，“M”为分钟，“S”为秒。单位是【 H\\M\\S】的情况下必须使用”T”。例如, 1234减2个小时：&quot;-PT2H&quot;加2分钟：&quot;PT2M&quot;加2秒：&quot;PT2S&quot;加2天：”P2D“ 第四个参数，区域语言设置。 第五个参数，跟time的第二个函数同义。","categories":[{"name":"测试工具","slug":"测试工具","permalink":"https://emilyty.github.io/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://emilyty.github.io/tags/jmeter/"}]},{"title":"获取UTC时间、从json结构里通过筛选条件获取指定字段的value","slug":"python学习第一天","date":"2020-11-17T09:28:14.000Z","updated":"2020-11-17T11:06:05.575Z","comments":true,"path":"2020/11/17/python学习第一天/","link":"","permalink":"https://emilyty.github.io/2020/11/17/python%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9/","excerpt":"","text":"需要实现得需求：获取0时区（UTC）的时间；可以加减秒数；时间格式为 yyyy-MM-dd’T’HH：mm：ss.SSS 1234567import datetimenow = datetime.datetime.utcnow()delta = datetime.timedelta(seconds=30) #加30秒n_seconds = now + deltastart = n_seconds.isoformat() #把时间格式化startTime = str(start)[:-3]+&#x27;Z&#x27; #去掉最后的三个字符，加上Zprint (startTime) #2020-11-17T09:23:38.278Z 从接口返回的数据中通过某一个字段找出其它字段的值，再该需求中知道name字段的值是多少，通过name字段找出其它key的value。name不重复。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import requestimport jsonheaders = &#123;&#x27;content-type&#x27;: &#x27;application/json&#x27;,&#x27;token&#x27;:&#x27;test_token&#x27;&#125;url = &#x27;http://test.com/test/index&#x27;rs = request.get(url,headers = headers)jsonTest = json.loads(rs.text)&#x27;&#x27;&#x27;/例如，上面接口返回json结构如下：&#123;&#123; &quot;total&quot;:10, &quot;pageSize&quot;:100, &quot;pageNum&quot;:1, &quot;data&quot;:[ &#123; &quot;id&quot;:&quot;10001&quot;, &quot;name&quot;:&quot;我是测试数&quot;, &quot;status&quot;:&quot;已发布&quot;, &quot;objectName&quot;:&quot;我是测试数据-name&quot;, &quot;Fqn&quot;:&quot;test.data2&quot; &#125;, &#123; &quot;id&quot;:&quot;10002&quot;, &quot;name&quot;:&quot;newdata&quot;, &quot;status&quot;:&quot;PUBLISHED&quot;, &quot;objectName&quot;:&quot;新的数据&quot;, &quot;Fqn&quot;:&quot;test.data2&quot; &#125; ], &quot;pages&quot;:2&#125;&#125;&#x27;&#x27;&#x27;test_data = jsonTest.get(&#x27;data&#x27;) #获取到data下的所有数据，list类型targetDate = [] #这里也不一定用list，后面再看，总之先实现了功能for i in test_data: name = i.get(&#x27;name&#x27;) #i是dict,可以通过key获取到value if name == &#x27;新的数据&#x27;: targetDate.append(i[&#x27;name&#x27;]) #把字典里value添加到list中 targetDate.append(i[&#x27;objectName&#x27;]) targetDate.append(i[&#x27;Fqn&#x27;]) targetDate.append(i[&#x27;id&#x27;])#通过上面的数据生成新的json结构#新的json结构如下，先这么写着，还没改造好。action = &#123; &quot;id&quot;:targetDate[3], &quot;name&quot;:&quot;随便取一个&quot;, &quot;startTime&quot;:startTime, &quot;endTime&quot;:endTime, &quot;objectFqn&quot;:targetDate[2], &quot;objectName&quot;:targetDate[1], &quot;objectEntityName&quot;:targetDate[0]&#125; 生成多层json结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#生成如下json格式&#x27;&#x27;&#x27;&#123; &quot;OpportunityId&quot;:&quot;507384&quot;, &quot;ruleContent&quot;:&#123; &quot;root&quot;:&#123; &quot;nodeType&quot;:&quot;OPERATOR&quot;, &quot;nodeOperator&quot;:&#123; &quot;operator&quot;:&quot;AND&quot; &#125;, &quot;children&quot;:[ &#123; &quot;nodeType&quot;:&quot;OPERATOR&quot;, &quot;nodeOperator&quot;:&#123; &quot;operator&quot;:&quot;开头是&quot; &#125;, &quot;children&quot;:[ &#123; &quot;nodeType&quot;:&quot;PROPERTY&quot;, &quot;nodeProperty&quot;:&#123; &quot;dataType&quot;:&#123; &quot;dataTypeBasis&quot;:&quot;Email&quot;, &quot;dataTypeRestrict&quot;:&quot;SINGLE&quot; &#125;, &quot;conditionId&quot;:&quot;500685&quot;, &quot;conditionName&quot;:&quot;StringEmail&quot; &#125; &#125;, &#123; &quot;nodeType&quot;:&quot;VALUE&quot;, &quot;nodeValue&quot;:&#123; &quot;value&quot;:&#123; &quot;type&quot;:&#123; &quot;dataTypeBasis&quot;:&quot;String&quot;, &quot;dataTypeRestrict&quot;:&quot;SINGLE&quot; &#125;, &quot;value&quot;:&quot;口头&quot; &#125; &#125; &#125; ] &#125;, &#123; &quot;nodeType&quot;:&quot;OPERATOR&quot;, &quot;nodeOperator&quot;:&#123; &quot;operator&quot;:&quot;EQ&quot; &#125;, &quot;children&quot;:[ &#123; &quot;nodeType&quot;:&quot;PROPERTY&quot;, &quot;nodeProperty&quot;:&#123; &quot;dataType&quot;:&#123; &quot;dataTypeBasis&quot;:&quot;Url&quot;, &quot;dataTypeRestrict&quot;:&quot;SINGLE&quot; &#125;, &quot;conditionId&quot;:&quot;500679&quot;, &quot;conditionName&quot;:&quot;StringUrl&quot; &#125; &#125;, &#123; &quot;nodeType&quot;:&quot;VALUE&quot;, &quot;nodeValue&quot;:&#123; &quot;value&quot;:&#123; &quot;type&quot;:&#123; &quot;dataTypeBasis&quot;:&quot;String&quot;, &quot;dataTypeRestrict&quot;:&quot;SINGLE&quot; &#125;, &quot;value&quot;:&quot;ereger&quot; &#125; &#125; &#125; ] &#125; ] &#125;, &quot;expression&quot;:&quot;[&#123;&quot;rootOperator&quot;:&quot;AND&quot;,&quot;operator&quot;:&quot;starts with&quot;,&quot;conditionName&quot;:&quot;StringEmail&quot;,&quot;firstValue&quot;:&quot;口头&quot;,&quot;lastValue&quot;:&quot;&quot;,&quot;conditionNameI18n&quot;:&#123;&quot;zh-CN&quot;:&quot;StringEmail&quot;&#125;&#125;,&#123;&quot;rootOperator&quot;:&quot;AND&quot;,&quot;operator&quot;:&quot;=&quot;,&quot;conditionName&quot;:&quot;StringUrl&quot;,&quot;firstValue&quot;:&quot;ereger&quot;,&quot;lastValue&quot;:&quot;&quot;,&quot;conditionNameI18n&quot;:&#123;&quot;zh-CN&quot;:&quot;StringUrl&quot;&#125;&#125;]&quot; &#125;&#125;&#x27;&#x27;&#x27;import jsonconditionJson = &#123;&#125;data = json.loads(json.dumps(conditionJson))OpportunityId = &#x27;507372&#x27;data[&#x27;OpportunityId&#x27;] = OpportunityIdruleContent = &#123;&#x27;root&#x27;: &#123;&#125; ,&#x27;expression&#x27;: []&#125;data[&#x27;ruleContent&#x27;] = ruleContentroot = &#123;&#x27;nodeType&#x27;:&quot;OPERATOR&quot;,&#x27;nodeOperator&#x27;:&#123; &#x27;operator&#x27;:&#x27;AND&#x27; &#125;,&#x27;children&#x27;:[]&#125;data[&#x27;ruleContent&#x27;][&#x27;root&#x27;] = root#先生产这个conditionId =&#x27;&#x27;openid = &#x27;&#x27;dataTypeBasis = &#x27;&#x27;value = &#x27;&#x27;children = [&#123;&#x27;nodeType&#x27;:&#x27;PROPERTY&#x27;,&#x27;nodeProperty&#x27;:&#123;&#x27;dataType&#x27;:&#123;&#x27;dataTypeBasis&#x27;:dataTypeBasis,&#x27;dataTypeRestrict&#x27;:&#x27;SINGLE&#x27;&#125;,&#x27;conditionId&#x27;:conditionId,&#x27;conditionName&#x27;:openid&#125;&#125;,&#123;&#x27;nodeType&#x27;:&#x27;VALUE&#x27;,&#x27;nodeValue&#x27;:&#123;&#x27;value&#x27;:&#123;&#x27;type&#x27;:&#123;&#x27;dataTypeBasis&#x27;:dataTypeBasis,&#x27;dataTypeRestrict&#x27;:&#x27;SINGLE&#x27;&#125;,&#x27;value&#x27;:value&#125;&#125;&#125;]operator = &#x27;开头是&#x27;children = [&#123;&#x27;nodeType&#x27;:&#x27;OPERATOR&#x27;,&#x27;nodeOperator&#x27;:&#123;&#x27;operator&#x27;: operator&#125;,&#x27;children&#x27;:children&#125;,&#123;&#x27;nodeType&#x27;:&#x27;OPERATOR&#x27;,&#x27;nodeOperator&#x27;:&#123;&#x27;operator&#x27;: operator&#125;,&#x27;children&#x27;:[]&#125;]data[&#x27;ruleContent&#x27;][&#x27;root&#x27;][&#x27;children&#x27;] = childrenlconditionJson = json.dumps(data, ensure_ascii=False)print(lconditionJson)","categories":[{"name":"python","slug":"python","permalink":"https://emilyty.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://emilyty.github.io/tags/python/"}]},{"title":"软件测试从业者，需掌握的数据库体系知识","slug":"软件测试从业者，需掌握的数据库体系知识","date":"2020-11-16T05:43:18.000Z","updated":"2020-11-16T08:42:40.614Z","comments":true,"path":"2020/11/16/软件测试从业者，需掌握的数据库体系知识/","link":"","permalink":"https://emilyty.github.io/2020/11/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%BB%8E%E4%B8%9A%E8%80%85%EF%BC%8C%E9%9C%80%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86/","excerpt":"","text":"从知识体系的角度，数据库、Linux、测试理论、软件工程知识、计算机基础、网络基础、服务器 基础、程序语言基础（Java / Python）等，都是软件测试从业者必须具备的基础知识。 如上，各方面，之前有文章专题聊过。响应各从业者需求，聊聊数据库这块 。 老徐一直认为数据库没啥好讲的，就那么点东西，自己折腾下就会了。然而，从实际的了解来看，很多从业者对数据库是有强需求，有些甚至工作中都没接触过数据库，导致第一次接触时，完全没概念 。**** **** 软件测试从业者，需要掌握的数据库知识体系可以分为三个阶段 。**** 第一阶段（多数测试从业者足够）\\1. 至少得知道常见的数据库类型Mysql 、MSSQL 、 Oracle 、 Memcached 、 Redis 、 Mongodb 等注：如下以MYSQL为例 。\\2. 数据库的安装、部署 ，基础使用 。你至少得会自己在服务器 或 自己电脑上安装个数据库。 3. 常见的数据库链接工具。如 WorkBench Navicat phpMyAdmin 等 。\\4. 数据库基础配置 。修改密码、添加用户等。\\5. 创建/删除库、创建/删除表、查看库、查看表。\\6. 基本的增删改查 语句。 第二阶段（一些对数据有强需求的业务测试）\\7. 备份、还原数据库 。\\8. 稍微复杂点的SQL 多表查询、子查询 等等。\\9. 存储过程 、视图 等。10.数据导入、导出数据 等。11.造数据。实际测试过程中，经常需要通过数据库造一些测试数据。 第三阶段（数据库的一些优化知识、安全知识 等 ，多数测试同学可以不掌握）****如：慢SQL 、SQL优化、使用规范等 。主要是方便：定位问题、性能优化 等。 End补充：具体的常用SQL语句，大家是否有需求否？如有，老徐可以简单列一些高频的 。** 最后，送上一本数据库相关的电子书，后台回复「MySQL」直接下载 。**","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://emilyty.github.io/tags/mysql/"}]},{"title":"mysql常用语法学习下","slug":"mysql常用语法学习下","date":"2020-11-16T05:38:17.000Z","updated":"2020-11-16T05:39:21.557Z","comments":true,"path":"2020/11/16/mysql常用语法学习下/","link":"","permalink":"https://emilyty.github.io/2020/11/16/mysql%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B8%8B/","excerpt":"","text":"第17天作业 ， – 1）修改表idoxu，把字段istester ，改为istester6（字符类型varchar，长度160 ） – 2）检查是否修改成功 – 3）把idoxu表，改名为 idoxu6 – 4）检查是否修改成功 前一天作业答案参考 ， 造数据 ，把istester表的所有数据，插入到 idoxu表 字段关系 id 取id stu_id 取id c_name 取 uname istester 和 grade字段，给默认值 60 insert into idoxu(id,stu_id,c_name,istester,grade) select id,id,uname,60,60 from istester ; / 第18天作业 ， 1）创建数据库 istesterdb6 2）检查数据库是否创建成功 ； 3）进入istesterdb6 库 4）在数据库 istesterdb6 ，创建idoxu表，直接拷贝 istester库idoxu6表的数据和结构 ； 5）检查表是否创建成功 ； 前一天作业答案参考 ， – 1）修改表idoxu，把字段istester ，改为istester6（字符类型varchar，长度160 ） alter table idoxu CHANGE istester istester6 varchar(160); – 2）检查是否修改成功 desc idoxu; – 3）把idoxu表，改名为 idoxu6 – ALTER TABLE 旧表名 RENAME TO 新表名 ; ALTER TABLE idoxu RENAME TO idoxu681 ; – 4）检查是否修改成功 show tables; / 第19天作业 ， idoxu表，分数grade 1）排名前三的学生 和分数 ； 2）排名3 - 6名的学生 和分数 ； 3）排名6名以后的所有学生 和分数 ； 前一天作业答案参考 ， 1）创建数据库 istesterdb6 create database istesterdb6 ; 2）检查数据库是否创建成功 ； show databases ; 3）进入istesterdb6 库 use istesterdb6 ; 4）在数据库 istesterdb6 ，创建idoxu表，直接拷贝 istester库idoxu6表的数据和结构 ； create table istesterdb6.idoxu as SELECT * from istester.idoxu6; 或 create table idoxu as SELECT * from istester.idoxu6; 5）检查表是否创建成功 ； show tables; / 第20天作业 ， 多表（左链接、右链接、内链接） 表 idoxu6 和 表istester 前一天作业答案参考 ， – 1）排名前三的学生 和分数 ； SELECT c_name,grade FROM idoxu ORDER BY grade DESC LIMIT 3; – 2）排名3 - 6名的学生 和分数 ； SELECT c_name,grade FROM idoxu ORDER BY grade DESC LIMIT 2,4; – 3）排名6名以后的所有学生 和分数 ； SELECT c_name,grade FROM idoxu ORDER BY grade DESC LIMIT 5,666; 注：这题目的是limit的用法，很多同学写的太复杂 ； limit是mysql的语法 select * from table limit m,n 其中m是指记录开始的index，从0开始，表示第一条记录 n是指从第m+1条开始，取n条。 select * from tablename limit 2,4 即取出第3条至第6条，4条记录 / 第21天作业（最后1天，结业） ， 1）把表idoxu6，改完idoxu 2）删除库 istesterdb6 3）删除istester表 4）清空idoxu表的数据 End ，一切恢复如初，坐等SQL第2期 ； 前一天作业答案参考 ， 注：主要目的是熟悉这三种玩法，以及观察结果差异 ； #左连接 SELECT * from idoxu6 a LEFT JOIN istester b on a.stu_id=b.id; #内连接 SELECT * from idoxu6 a INNER JOIN istester b on a.stu_id=b.id; #右连接 SELECT * from idoxu6 a RIGHT JOIN istester b on a.stu_id=b.id; / 结业，最后一天作业答案参考 1）把表idoxu6，改名为idoxu rename table idoxu6 to idoxu; 或 alter table idoxu6 rename idoxu; 2）删除库 istesterdb6 drop database istesterdb6; 3）删除istester表 drop table istester; 4）清空idoxu表的数据 truncate table idoxu; 或 delete from idoxu; End ，恭喜结业 ； 循环3次21天打卡，总共63天（两个月掌握软测必备的SQL日常使用）","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://emilyty.github.io/tags/mysql/"}]},{"title":"mysql常用语法学习中","slug":"mysql常用语法学习中","date":"2020-11-16T05:37:36.000Z","updated":"2020-11-16T05:39:56.000Z","comments":true,"path":"2020/11/16/mysql常用语法学习中/","link":"","permalink":"https://emilyty.github.io/2020/11/16/mysql%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B8%AD/","excerpt":"","text":"第8天作业 ， 继续 select 1）查找idoxu表，名称（c_name）包含 “i” 的数据 2）查找istester表，id 包含 “1” 的数据 3）查找istester表，id 包含 “1” 的数据，按id降序 4）查找istester表，id 包含 “1” 的数据 ，取id最大的三个 前一天作业答案参考 ， 1）查询istester表 id = 1的内容 select * from istester where id = 1; 2）查询idoxu 表 grade=100 的内容 select * from idoxu where grade =100; / 第9天作业 ， 1）找出idoxu表中，分数最高的同学和分数 2）找出idoxu表中，分数最低的同学和分数 前一天作业答案参考 ， 1）查找idoxu表，名称（c_name）包含 “i” 的数据 select * from idoxu where c_name like ‘%i%’ ; 2）查找istester表，id 包含 “1” 的数据 select * from istester where id like ‘%1%’; 3）查找istester表，id 包含 “1” 的数据，按id降序 select * from istester where id like ‘%1%’ order by id desc ; 4）查找istester表，id 包含 “1” 的数据 ，取id最大的三个 select * from istester where id like ‘%1%’ order by id desc limit 3 ; / 第10天作业 ， – 1) 找出istester表，sex为空的的数据； – 2）更新istester表，把sex为空的，设置为0（性别未知） – 3）找出idoxu表，grade小于60分的同学 – 4）更新idoxu表，把grade小于60分的同学，一律改为59分 前一天作业答案参考 ， – 1）找出idoxu表中，分数最高的同学和分数； SELECT c_name,grade as “maxvalue” from idoxu WHERE grade in (select MAX(grade) from idoxu ) ; – 2）找出idoxu表中，分数最低的同学和分数； SELECT c_name,grade as “minvalue” from idoxu WHERE grade in (SELECT MIN(grade) from idoxu ); / 第11天作业 ， – 1）查找istester表，按id降序 – 2）查找idoxu表，按grade升序 前一天作业答案参考 ， – 1) 找出istester表，sex为空的的数据； select * from istester where sex is null ; – 2）更新istester表，sex为空的，设置为0（性别未知） update istester set sex = 0 where sex is null ; – 3）找出idoxu表，grade小于60分的同学 select * from idoxu where grade &lt; 60 ; – 4）更新idoxu表，把grade小于60分的同学，一律改为59分 update idoxu set grade = 59 where grade &lt; 60 ; / 第12天作业 ， 1）查询istester表，有多少条数据 2）查询istester表，有几种性别类型（sex字段，去重） 前一天作业答案参考 ， – 1）查找istester表，按id降序 select * from istester order by id desc; – 2）查找idoxu表，按grade升序 select * from idoxu order by grade; / 第13天作业 ， 1）查找idoxu表，学生成绩(grade) 总分 2）查找idoxu表，学生成绩(grade) 平均分 前一天作业答案参考 ， 1）查询istester表，有多少行数据 select COUNT(sex) from istester; 2）查询istester表，有性别类型数量（sex字段，去重） select COUNT(DISTINCT sex) from istester; / 第14天作业 ， 1）查找idoxu表，成绩在80 - 100区间的学生 ； 2）查找istester表，id 为 2，11，12 的数据 ； 前一天作业答案参考 ， 1）查找idoxu表，学生成绩(grade) 总分 select sum(grade) as sumgrade from idoxu ; 2）查找idoxu表，学生成绩(grade) 平均分 select avg(grade) as avggrade from idoxu ; / 第15天作业 ， 1）删除 istester表，id大于12的数据 ； 2）删除idoxu表，分数grade不及格（小于60分）的数据 ； 前一天作业答案参考 ， – 1）查找idoxu表，成绩在80 - 100区间的学生 ； select * from idoxu where grade between 80 and 100; – 2）查找istester表，id 为 2，11，12 的数据 ； select * from istester where id in (2,11,12) ; / 第16天作业 ， 1）造数据 ，把istester表的所有数据，插入到 idoxu表 字段取值规则 id 取id stu_id 取id c_name 取 uname istester 和 grade字段，给默认值 60 前一天作业答案参考 ， 1）删除 istester表，id大于12的数据 ； delete from istester where id &gt; 12; 2）删除idoxu表，分数grade不及格（小于60分）的数据 ； delete from idoxu where grade &lt; 60 ;","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://emilyty.github.io/tags/mysql/"}]},{"title":"mysql常用语法学习上","slug":"mysql常用语法学习上","date":"2020-11-16T05:35:47.000Z","updated":"2020-11-16T05:40:53.418Z","comments":true,"path":"2020/11/16/mysql常用语法学习上/","link":"","permalink":"https://emilyty.github.io/2020/11/16/mysql%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B8%8A/","excerpt":"","text":"开始前的准备事项，第0天 ， 开始之前的，前置准备事项： 1、在自己电脑上安装一个mysql数据库，文章见 -&gt; http://istester.com/article/258.html 2、找一个mysql客户端链接工具：推荐workbench ，安装包 http://istester.com/article/405.html / 第1天作业 ， 1）创建数据库 istester 2）查看数据库创建是否成功 / 第2天作业 ， 在昨天创建的isTester数据库下，创建 表 istester 和 表 idoxu 注：SQL的作业，前几天的 库、表，都是打基础；没有这些，后面的增删改查，你也没法玩 ； 1）isTester表的字段、类型、属性： id INT(10) NOT NULL UNIQUE PRIMARY KEY , uname VARCHAR(20) NOT NULL , sex VARCHAR(4) , birth YEAR, department VARCHAR(20) , address VARCHAR(50) , idoxu VARCHAR(20) 2）idoxu表的字段、类型、属性： id INT(10) NOT NULL UNIQUE PRIMARY KEY AUTO_INCREMENT , stu_id INT(10) NOT NULL , c_name VARCHAR(20) , istester VARCHAR(50) , grade INT(10) 前一天作业答案参考 ， 1）创建数据库 istester DROP DATABASE IF EXISTS istester; CREATE DATABASE IF NOT EXISTS istester; 2）查看数据库创建是否成功 show DATABASES; / 第3天作业 ， 根据已有的表istester 和 idoxu 创建新表（复制表） 1）复制istester表结构，创建新表istester2 注：可以有两种方式 2）复制idoxu表结构和数据，创建新表idoxu2 3）复制idoxu表结构的 id,stu_id,istester三个字段，创建新表idoxu3 前一天作业答案参考 ， 创建istester和idoxu表 CREATE TABLE istester ( id INT(10) NOT NULL UNIQUE PRIMARY KEY , uname VARCHAR(20) NOT NULL , sex VARCHAR(4) , birth YEAR, department VARCHAR(20) , address VARCHAR(50) , idoxu VARCHAR(20) ); CREATE TABLE idoxu ( id INT(10) NOT NULL UNIQUE PRIMARY KEY AUTO_INCREMENT , stu_id INT(10) NOT NULL , c_name VARCHAR(20) , istester VARCHAR(50) , grade INT(10) ); / 第4天作业 ， 1）删除表 istester2 2）同时删除表idoxu2和idoxu3 3）查看还有哪些表 前一天作业答案参考 ， 1）复制istester表结构，创建新表istester2 注：可以有两种方式 create table istester2 like istester ; 或 create table idoxu2 as select * from idoxu where 2=1; 2）复制idoxu表结构和数据，创建新表idoxu3 create table idoxu3 as select * from idoxu 3）复制idoxu表结构的 id,stu_id,istester三个字段，创建新表idoxu3 create table idoxu3 as select id,stu_id,istester from idoxu where 1&lt;&gt;1; / 第5天作业 ， 1）修改istester表，添加一个字段istester6 （字符类型VARCHAR，长度100，不允许为空） 2）查看字段istester6 ，是否添加成功 3）修改istester表，删除字段istester6 4）确认字段istester6 ，是否删除成功 前一天作业答案参考 ， 1）删除表 istester2 drop table istester2 ; 2）同时删除表idoxu2和idoxu3 drop table idoxu2,idoxu3 ; 3）查看还有哪些表 show tables; / 第6天作业 ， 插入 insert： 1）向表istester插入数据 id = 1 ,uname = idoxu ,idoxu = 2020 id = 2 ,uname = idoxu2 ,idoxu = 2020 id=11,uname = idoxu3,sex=1 id=12,uname = idoxu4,sex=2 id=13,uname = idoxu5,sex=1 id=14,uname = idoxu6,sex=2 2）向表idoxu插入数据 id=4,stu_id=11,c_name=idoxu,grade=90 id=5,stu_id=12,c_name=lin,grade=100 id=6,stu_id=33,c_name=istester,grade=20 前一天作业答案参考 ， 1）修改istester表，添加一个字段istester6 （字符类型VARCHAR，长度100，不允许为空） ALTER table istester add column istester6 VARCHAR(100) NOT NULL; 2）查看字段istester6 ，是否添加成功 desc istester 3）修改istester表，删除字段istester6 ALTER table istester drop istester6 4）确认字段istester6 ，是否删除成功 desc istester / 第7天作业 ， 1）查询istester表 id = 1 的内容 2）查询idoxu 表 grade=100 的内容 前一天作业答案参考 ， 插入 insert： 1）向表istester插入数据 id = 1 ,uname = idoxu ,idoxu = 2020 id = 2 ,uname = idoxu2 ,idoxu = 2020 id=11,uname = idoxu3,sex=1 id=12,uname = idoxu4,sex=2 id=13,uname = idoxu5,sex=1 id=14,uname = idoxu6,sex=2 2）向表idoxu插入数据 id=4,stu_id=11,c_name=idoxu,grade=90 id=5,stu_id=12,c_name=lin,grade=100 id=6,stu_id=33,c_name=istester,grade=20 参考语句： insert into istester(id,uname,idoxu) values(1,”idoxu”,2020); insert into istester(id,uname,idoxu) values(2,”idoxu2”,2020); insert into istester(id,uname,sex) values(11,”idoxu3”,1),(12,”idoxu4”,2),(13,”idoxu5”,1),(14,”idoxu6”,2); insert into idoxu(id,stu_id,c_name,grade) values(4,11,”idoxu”,90),(5,12,”lin”,100),(6,33,”istester”,20);","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://emilyty.github.io/tags/mysql/"}]},{"title":"软件测试常用linux命令","slug":"软件测试常用linux命令","date":"2020-11-16T04:22:34.000Z","updated":"2020-11-16T05:42:44.613Z","comments":true,"path":"2020/11/16/软件测试常用linux命令/","link":"","permalink":"https://emilyty.github.io/2020/11/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8linux%E5%91%BD%E4%BB%A4/","excerpt":"","text":"命令 cd 如何进入上级目录 1cd .. 如何进入当前用户主目录 cd ~ 如何进入上两级目录 cd ../.. 进入当前目录命令 cd . 如何进入目录 /usr/isTester cd /usr/isTester 命令 mv 移动一个文件夹（isTester文件夹，移动到/APP/www目录） mv ~/isTester/ /APP/www 移动一个文件（isTester.ini 移动到/APP/www目录） mv isTester.ini /APP/www 当前目录istester.tar.gz 移动到 /usr/ido 目录，并重命名为istester1228.tar.gz mv isTester.tar.gz /usr/ido/ido.tar.gz 移动文件到上级目录 mv isTester.tar.gz ../ 一条命令，移动两个文件 isTester.tar idoxu.tar 到目录 /APP/www mv isTester.tar idoxu.tar -t /APP/www 命令 cp 复制当前目录部署包isTester.tar.gz 到备份目录/APP/www/bak 目录 cp isTester.tar.gz /APP/www/bak 复制文件夹 isTester 到部署目录 /APP/www cp -r isTester/ /APP/www 命令 mkdir 在目录/APP/www 下， cd /APP/www 新建一个文件夹 isTester mkdir isTester 新建三个文件夹 isTester1 isTester2 isTester3 mkdir isTester1 isTester2 isTester3 新建一个多层级文件夹 idoxu/20181230/01 mkdir -p idoxu/20181230/01 命令 history 查看历史命令执行记录 history 查看命令mkdir 的历史执行记录 history | grep mkdir 执行历史记录中，序号为178的命令 !178 命令 tail 实时刷新log tail -f isTester.log 实时刷新最新500条log tail -500f isTester.log 命令 tar 压缩一个文件 isTester.ini tar -cvf isTester.tar isTester.ini 压缩多个文件 isTester.ini readme.ini tar -cvf all.tar isTester.ini readme.ini 压缩文件夹 isTester/ tar -cvf isTester.tar isTester/ 将当前目录，所有jpg文件打包成isTesterjpg.tar tar -cvf isTesterjpg.tar *.jpg 将当前目录，所有jpg文件打包成isTesterjpg.tar.gz tar -zcvf isTesterjpg.tar.gz *.jpg 解压 isTesterjpg.tar tar -xvf isTesterjpg.tar 解压 isTesterjpg.tar.gz tar -zxvf isTesterjpg.tar.gz 命令 ls 列出当前目录中所有的子目录和文件。 ls 列出目录下的所有文件（包含隐**件） ls -a 列出文件的详细信息（包括权限、所有者、文件大小等） ls -l 列出当前目录中所有以“isTester”开头的详细内容 ls -l isTester* 命令 ps 查看所有进程 ps -A 查看java进程 ps -ef|grep java 显示所有进程信息，连同命令行 ps -ef 命令 top 显示进程信息 top 监控每个逻辑CPU的状况 top ，按 1 高亮显示当前运行进程 top ，按 b 显示 完整命令 top ，按 c 退出top程序 按 q 命令wget Linux系统中的wget是一个下载文件的工具，对于Linux用户是必不可少的工具 文件地址 http://51.istester.com/isTester.png 下载isTester.jpg文件 wget http://51.istester.com/isTester.png 下载isTester.jpg文件，并存储名为isTester_Logo.jpg wget -o isTester_Logo.jpg http://51.istester.com/isTester.png 下载isTester.jpg文件，后台形式下载 wget -b http://51.istester.com/isTester.png 命令 find ​ find命令，非常强大，也非常实用，分两次完成，今日第一次 。 ​ 给大家布置的作业，是比较实用的几个场景 。 在/root/isTester 目录及其子目录下面查找名字为isTester.ini的文件 find /root/isTester/ -name isTester.ini 在当前目录及其子目录中查找任何扩展名为“ini”的文件 find . -name “*.ini” 在/root/isTester目录下查找更改时间在5日以内的文件 ​ find /root/isTester/ -mtime +5 在/root/isTester目录下查找更改时间在3日以前的文件 find /root/isTester/ -mtime -3 在/root/isTester目录下查找所有的目录 find . -type d 在/root/isTester目录下查找所有的文件 find /root/isTester/ -type f 命令 继续find（进阶） find命令，非常强大，也非常实用，分两次完成，今日第一次 。 给大家布置的作业，是比较实用的几个场景 。 在当前目录，所有的普通文件中搜索istester这个词 find ./ -type f |xargs grep “istester” 在当前目录，删除1天以内的所有东西 find ./ -mtime -1 -print | xargs rm -rf 在当前目录，删除10天以前的所有东西（实操的时候，需谨慎，确保在自己建的目录内，别把系统目录删了…） find ./ -mtime +10 -print | xargs rm -rf 删除文件大小为零的文件 find ./ -size 0 | xargs rm -rf 命令 rm rm是常用的命令，该命令的功能为删除目录/文件（可同时删除，多个文件 / 多个目录） 当然，这也是一个非常危险的命令，建议少用（比如经常出现的误操作 rm * -rf 此命令慎用） 删除/root/isTester/目录下的文件isTester.ini （系统会询问是否删除） rm /root/isTester/isTester.ini 强行删除/root/isTester/目录下的文件isTester.ini（直接删除，系统不会提示） ​ rm -f /root/isTester/isTester.ini 删除/root/isTester/目录下的所有.log文件 ​ rm -f /root/isTester/*.log 删除/root/isTester/目录下的 ido/文件夹 ​ rm -r /root/isTester/ido/ 强行删除/root/isTester/目录下的 ido/文件夹 ​ rm -rf /root/isTester/ido/ 删除/root/isTester/目录下的所有内容 ​ rm -rf /root/isTester/* 文件操作系列 命令 创建文件，你知道有哪几个命令 ？（写出至少两种方式） touch isTester.ini vi isTester.md echo ‘only test’ &gt; isTester.com cp isTester.ini isTester666.ini ls &gt; fileList.txt 同时创建文件 isTester6.ini idoxu.ini touch isTester6.ini idoxu.ini 同时创建2000个文件 isTester0001.ini - isTester2000.ini touch istester{0001..2000}.ini 更改文件 isTester.ini时间为当前时间 touch isTester.ini 查看文件系列 命令 命令提示 #cat 由第一行开始显示档案内容 #tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ #more 一页一页的显示档案内容 #less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ #head 只看头几行 #tail 只看尾巴几行 #nl 显示的时候，顺道输出 行号！ 查看文件 isTester.ini的内容 ​ cat isTester.ini 看文件 isTester.ini前20行内容 ​ head -n 20 isTester.ini 看文件 isTester.ini最后30行内容 ​ tail -n 30 isTester.ini 显示文件isTester.ini 的第10至20行的内容 ​ head -n 20 isTester.ini | tail -n 10 倒序显示文件isTester.ini 前10行的内容 ​ tac isTester.ini | head -n 10 显示文件isTester.ini 前10行的内容，并显示行号 ​ nl isTester.ini | head -n 10 命令 yum &amp; scp # 假设 当前服务器ip 192.168.1.23 从Linux服务器192.168.1.22 拷贝文件isTester.ini 到服务器192.168.1.23 scp &#x72;&#111;&#x6f;&#116;&#x40;&#49;&#x39;&#50;&#46;&#49;&#54;&#x38;&#x2e;&#49;&#x2e;&#50;&#50;:/root/idoxu/isTester.ini /root/idoxu 从Linux服务器192.168.1.22 拷贝目录 isTester/ 到服务器192.168.1.23 scp -r &#x72;&#x6f;&#x6f;&#116;&#64;&#49;&#x39;&#x32;&#x2e;&#49;&#54;&#x38;&#x2e;&#49;&#46;&#50;&#50;:/root/idoxu/isTester/ /root/idoxu Linux下安装scp命令（假设是centos服务器，命令用yum） yum install openssh-clients 命令 clear df du ifconfig 查看当前服务器ip ifconfig 查看当前服务器硬盘空间 df -h 查看目录isTester/ 所占有的空间 du -sh isTester 清空当前终端屏幕 clear 命令 vi + chmod /** vi 创建文件 + 编辑文件 。 chmod命令用于改变linux系统文件或目录的访问权限 。 **/ 创建文件 isTester.ini vi isTester.ini 更新文件内容为“21 day Linux Learn ,I’m Idolaoxu,in shenzhen . ” 输入 i ，进入编辑模式，输入内容，esc进入命令模式 :wq 保存 。 将文件 isTester.ini 设为所有人皆可读取 chmod +r isTester.ini 将 isTester.ini 设定为只有该文件拥有者可以执行 chmod u+x isTester.ini 给文件 isTester.ini 设置所有权限 chmod 777 isTester.ini (或者 chmod a=rwx isTester.ini) 注：chmod还有很多命令用法，如上几种，满足日常需求 。 比如，想了解 top命令咋用 ？ 终端输入 top –help 即可 最后，关于Linux学习的几个建议 。 每个命令，多敲几次，每天掌握此文的一个命令即可，勿贪多 。 掌握了前面的一个命令，再继续下一个命令。否则，欠的技术债会越来越多，最后放弃学习 。 学Linux，没诀窍，多敲命令 。 此文的命令，一个循环，预计你需要21天完成 。总共三个循环 ，2个月，大功告成 。 所谓的三循环理论： 第一遍，花21天时间，把每个命令，敲一遍 。 第二遍，花21天时间，把每个命令，再熟悉一遍 。 第三遍，花21天时间，巩固，延伸更多命令组合玩法，熟记于心 。 如果你能看到这段文字，且是第三遍以上看到，恭喜你，Linux这块的知识点，差不多了 。 你，可以开始下一个环节 Jenkins / 接口自动化 / 数据库 / 性能测试 / 测试管理 等等 的 专项学习 。 事情很多，别急，慢慢来 。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://emilyty.github.io/tags/Linux/"}]},{"title":"github+hexo搭建博客遇到的坑","slug":"github-hexo搭建博客遇到的坑","date":"2020-11-15T03:24:30.000Z","updated":"2020-11-15T03:39:08.605Z","comments":true,"path":"2020/11/15/github-hexo搭建博客遇到的坑/","link":"","permalink":"https://emilyty.github.io/2020/11/15/github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/","excerpt":"","text":"搭建GitHub博客教程：https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html 为了防止失效，先截个图保存一下 1、hexo init一直卡住无法继续 12$ hexo initINFO Cloning hexo-starter https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo-starter.git 出现这个问题的主要原因是安装源，可以重置安装源为taobao 1npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org 2、本地博客hexo d提交到GitHub后通过username.github.io访问页面空白 GitHub页面默认读的是main分支，所以把分支改为master分支就可。入口为仓库的settings。","categories":[{"name":"工具","slug":"工具","permalink":"https://emilyty.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"搭建GitHub博客","slug":"搭建GitHub博客","permalink":"https://emilyty.github.io/tags/%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2/"}]},{"title":"hexo文章用Typora插入图片方法","slug":"hexo文章用Typora插入图片方法","date":"2020-11-15T03:04:01.000Z","updated":"2020-11-15T03:26:21.181Z","comments":true,"path":"2020/11/15/hexo文章用Typora插入图片方法/","link":"","permalink":"https://emilyty.github.io/2020/11/15/hexo%E6%96%87%E7%AB%A0%E7%94%A8Typora%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95/","excerpt":"","text":"Typora是一个markdown编辑器，可以直接贴入图片。配置如下 首先修改根目录的_config.yml文件 1post_asset_folder: true 通过$ hexo new page1 创建博客的时候source/_posts文件下生成一个同名文件夹 12page1.mdpage1 Typora偏好设置 image-20201115111213215 图片粘贴到文件后生成图片路径，并且把图片复制到同名的文件夹里。默认的图片路径push到git后无法访问，需要修改文件路径。 默认生成的图片路径为![tupian](page1/putian.jpg)，把图片路径修改为 ![](tupian.jpg)就可以进行访问了。","categories":[{"name":"工具","slug":"工具","permalink":"https://emilyty.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"搭建GitHub博客","slug":"搭建GitHub博客","permalink":"https://emilyty.github.io/tags/%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2/"}]},{"title":"测试负责人都干了啥","slug":"从测试工程师到测试负责人","date":"2020-11-14T09:44:29.000Z","updated":"2020-11-15T01:22:34.452Z","comments":true,"path":"2020/11/14/从测试工程师到测试负责人/","link":"","permalink":"https://emilyty.github.io/2020/11/14/%E4%BB%8E%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%88%B0%E6%B5%8B%E8%AF%95%E8%B4%9F%E8%B4%A3%E4%BA%BA/","excerpt":"","text":"​ 作为测试负责人需要有大局观，对长期产品线来讲的话，产品发起需求沟通前主动询问产品规划，每个阶段需要完成的任务心里有数。根据产品规划协调资源，准备接任务。 ​ 下面再详细看看，作为测试负责人平时都干了什么活儿…… 需求沟通阶段 一. 需求规划阶段 找各个模块的产品经理获取产品规划书，对接下来要完成的任务有一个大概的范围 职能部门领导沟通工作量和时间节点，并提前申请部分测试资源 二. 需求沟通阶段 熟悉需求，并分析需求，有疑问的地方抛出问题，与产品共同讨论 组织相关人员拆分任务、评估时间和任务优先级 确认工作量、时间节点和相关可用资源 无法在迭代周期内完成的任务先找产品砍需求，不能砍的需求，让产品找职能部门申请更多的资源或者调整其它产品的优先级。 产品开发与测试阶段 一. 开发阶段 主动了解开发进度，每天发送进度报告，如有延期及时再邮件理提出 延期严重并跟开发本人沟通后，仍然不能解决的找相关负责人进行进一步的沟通 二. 测试阶段 提测前 根据需求制定合适的测试方案和测试策略 合理分配任务 审核测试工程师测试用例 组织用例评审 提测后 关注风险/延期，以及质量和进度的平衡 跟踪测试进度，严格把控时间 把控产品质量，每个测试工程师提交缺陷情况 监控测试用例执行情况，有必要的情况下抽查测试 及时询问，如有问题主动推动解决 随时准备接收临时任务和拒绝 根据需求和提测情况确定回归测试方案 测试验收阶段 组织相关负责人处理遗留问题，确认风险 出测试报告 审核工程师测试报告和风险 组织升级测试 &amp; 跟踪升级测试结果","categories":[{"name":"管理","slug":"管理","permalink":"https://emilyty.github.io/categories/%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"测试管理","slug":"测试管理","permalink":"https://emilyty.github.io/tags/%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86/"}]},{"title":"遇到的软件需求评审到发布的流程","slug":"遇到的软件需求评审到发布的流程","date":"2020-11-14T06:50:34.000Z","updated":"2020-11-14T07:33:16.373Z","comments":true,"path":"2020/11/14/遇到的软件需求评审到发布的流程/","link":"","permalink":"https://emilyty.github.io/2020/11/14/%E9%81%87%E5%88%B0%E7%9A%84%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%AF%84%E5%AE%A1%E5%88%B0%E5%8F%91%E5%B8%83%E7%9A%84%E6%B5%81%E7%A8%8B/","excerpt":"","text":"分享一下目前正在执行中的需求评审到发布的测试流程，主要是针对产品开发，项目开发的流程跟这个稍有区别。 需求评审 组织者：产品经理 参与人员：开发、测试、产品经理、相关领导 目的：确认需求是否完整、业务逻辑是否合理 通过标准：需求不存在逻辑漏洞，文档相对完善 作为测试人员可以做的事情：①提前阅读需求文档；②评审前或者评审中积极参与讨论，提出建议；③需求明显不合理的情况下有勇气拒绝； 任务拆分和评估 组织者：测试负责人（master） 参与人员：开发、测试、产品经理 任务拆分原则：可独立测试；必现实现和可选择实现的任务分开；可以发布和暂时不能发布的任务拆开；拆分后的任务可评估，不能太大； 测试方案和用例设计 公司内部统一测试用例编写方式，便于后期管理和维护； 尽量指定同一个人来编写，可以保持用例设计方法一致，后期维护快捷； 统一测试用例编写工具。 测试方案模板统一。 测试方案和用例评审 组织者：方案和用例设计者 参与人员：测试领导、测试人员、开发、产品经理 目的：用例和方案设计是否合理，逻辑是否清晰；覆盖率是否达标，有无遗漏点；对需求文档理解是否一致； 冒烟测试 - 执行者：开发或者测试人员 目的：冒烟通过是测试准入的标准，如果冒烟都不通过，那么就没有必要浪费时间了。 通常公司都要求开发自测，如果开发一直说已自测过，但是经常冒烟都不通过的情况下，测试可以提供一些冒烟用例给开发进行自测。 系统测试 - 执行测试：测试人员 测试方式：手动或者自动 注意试项：用例需要标注通过或失败；有问题必须建issue，不能口头通知后直接进行修改； 测试报告 编写人员：测试人员 注意试项：测试报告格式统一；包含发布风险和测试结果；包含依赖服务编排和测试通过编排；还可以增加更多的质量统计数据； 预发布环境验证 执行者：测试人员 目的：防止升级失败；一定程度上可以发现程序里写死某些环境变量的问题；验证开发提供的升级流程和运维编写的发布脚本是否正确； 最后附上流程图一张","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://emilyty.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://emilyty.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"软件测试流程","slug":"软件测试流程","permalink":"https://emilyty.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"}]},{"title":"jmeter如何连接mysql数据库","slug":"jmeter如何连接mysql数据库","date":"2018-02-23T07:24:57.000Z","updated":"2020-11-14T09:28:14.335Z","comments":true,"path":"2018/02/23/jmeter如何连接mysql数据库/","link":"","permalink":"https://emilyty.github.io/2018/02/23/jmeter%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"首先下载mysql驱动包（下载地址：http://download.csdn.net/download/emilyty/9586858）。然后把mysql的驱动包放在jmeter的lib目录下。 jmeter如何连接mysql数据库 1、在测试计划里引入mysql驱动包 点击【浏览】按钮，在jmeter/lib目录下选择mysql驱动包。如图所示： 2.添加线程组 选中测试计划-&gt;右键-&gt;添加-&gt;Threads(Users)-&gt;线程组 2 3.添加配置元件JDBC Connection Configuration 在线程组下添加JDBC Connection Configuration，添加方式如图所示： 3 4.配置JDBC Connection Configuration Variable Name： 变量名称，需要变量名绑定到池。需要唯一标识。与JDBC取样器中的相对应，决定JDBC取样的配置。简单理解就是在JDBC request的时候确定去哪个绑定的配置。 MaxNumber of Connection： 数据库最大链接数 PoolTimeout： 数据库链接超时，单位ms Idle Cleanup Interval （ms）： 数据库空闲清理的间隔时间，单位ms Auto Commit：自动提交。有三个选项，true、false、编辑（自己通过jmeter提供的函数设置） Transaction Isolation：事务间隔级别设置，主要有如下几个选项：（对JMX加解密） TRANSACTION_REPEATABLE_READ事务重复读、TRANSACTION_READ_COMMITTED事务已提交读 TRANSACTION_SERIALIZABLE事务序列TRANSACTION_READ_UNCOMMITTED事务未提交读、TRANSACTION_NODE事务节点、DEFAULT默认、编辑 Keep-Alive： 是否保持连接 Max Connection age （ms）：最大连接时长，超过时长的会被拒绝 Validation Query：验证查询，检验连接是否有效（数据库重启后之前的连接都失效，需要验证查询） Database URL：如jdbc:mysql://localhost:3306/test，表示本地数据库，3306端口，请求访问的数据库名称为test，如果是远程数据库，例如数据库所在服务器IP为：192.168.11.120，请求的数据库名称为UserInfo，URL为dbc:mysql://192.168.11.120:3306/UserInfo JDBCDriver Class： JDBC的类，如com.mysql.jdbc.Driver 5.添加jdbc request 在线程组下添加sampler-&gt;jdbc request 5 jdbc request中填写sql语句。 注意：variable name必须跟JDBC Connection Configuration里设置的variable name一致。 6.查看结果 添加查看结果树，聚合报告。 点击运行，运行结束后，查看结果。","categories":[{"name":"测试工具","slug":"测试工具","permalink":"https://emilyty.github.io/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://emilyty.github.io/tags/jmeter/"}]},{"title":"Config参数化方法","slug":"Config参数化方法","date":"2016-01-14T05:28:15.000Z","updated":"2020-11-14T07:56:04.353Z","comments":true,"path":"2016/01/14/Config参数化方法/","link":"","permalink":"https://emilyty.github.io/2016/01/14/Config%E5%8F%82%E6%95%B0%E5%8C%96%E6%96%B9%E6%B3%95/","excerpt":"","text":"1.创建csv文件，把需要的参数写在一列中。不需要写变量名称，直接写变量值就可以。 2.线程组中添加CSV Data Set Config 如图所示： ​ 3.设置CSV Data Set Config配置 ​ Filename中填写文件路径和文件名称。如果文件放在jmeter的bin目录下，直接写文件名称就可以。 Variable names中填写自定义变量名称。 Recycle on EOF：到了文件尾处，是否循环读取参数。 Stop thread on EOF:到了文件尾处，是否停止线程。 当Recycle on EOF选择true时，Stop threadon EOF选择true和false无任何意义，通俗的讲，在前面控制了不停的循环读取，后面再来让stop或run没有任何意义 当Recycle on EOF选择false时，Stop threadon EOF选择true，线程4个，参数3个，那么只会请求3次 当Recycle on EOF选择false时，Stop thread on EOF选择false，线程4个，参数3个，那么会请求4次，但第4次没有参数可取，不让循环，所以第4次请求错误 4.参数化固定值 需要使用变量的地方换成自定的变量名称，编写格式：${自定义的变量名称}，如图所示的格式填写： 1-3 5.循环读取参数： 1）通过线程组循环 Recycle on EOF和Stop thread on EOF进行设置，还需要把线程组的循环次数设置为需要的次数。 2）通过循环控制器循环 如果使用循环控制器的话，可以把线程组设置为1，需要循环的次数在循环控制器中设置。配合着Recycle on EOF和Stop thread on EOF的设置使用。 注：如果使用循环控制器，需要把CSV Data Set Config放在循环控制器下面。","categories":[{"name":"测试工具","slug":"测试工具","permalink":"https://emilyty.github.io/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://emilyty.github.io/tags/jmeter/"}]}],"categories":[{"name":"测试工具","slug":"测试工具","permalink":"https://emilyty.github.io/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"},{"name":"python","slug":"python","permalink":"https://emilyty.github.io/categories/python/"},{"name":"工具","slug":"工具","permalink":"https://emilyty.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"管理","slug":"管理","permalink":"https://emilyty.github.io/categories/%E7%AE%A1%E7%90%86/"},{"name":"软件测试","slug":"软件测试","permalink":"https://emilyty.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://emilyty.github.io/tags/jmeter/"},{"name":"python","slug":"python","permalink":"https://emilyty.github.io/tags/python/"},{"name":"mysql","slug":"mysql","permalink":"https://emilyty.github.io/tags/mysql/"},{"name":"Linux","slug":"Linux","permalink":"https://emilyty.github.io/tags/Linux/"},{"name":"搭建GitHub博客","slug":"搭建GitHub博客","permalink":"https://emilyty.github.io/tags/%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2/"},{"name":"测试管理","slug":"测试管理","permalink":"https://emilyty.github.io/tags/%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86/"},{"name":"软件测试","slug":"软件测试","permalink":"https://emilyty.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"软件测试流程","slug":"软件测试流程","permalink":"https://emilyty.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"}]}